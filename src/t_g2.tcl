################################################################################
# 
#   Э В О Л Ю Ц И О Н Н Ы Й   Д В И Ж О К
# 
################################################################################

  
#-------------------------------------------------------------------------------
# генерить случайное целое в интервале min-max (оба конца включены)
#-------------------------------------------------------------------------------
proc rand {min max} {
    expr {$min + int (rand() * (($max-$min)+1))}
}
#-------------------------------------------------------------------------------
# получить случайный элемент из списка
#-------------------------------------------------------------------------------
proc lrand list {
    lindex $list [expr {int (rand() * [llength $list])}]
}
#-------------------------------------------------------------------------------
# получить случайную инструкцию
#-------------------------------------------------------------------------------
proc randinstr {} {
    set instr [lrand $::instructions]
    set arglist [info args $instr]
    
    if {[llength $arglist] == 0} { #if {$arglist eq {}}  - для Tcl-8.4 
         #puts "iuiuiuiu"
        return $instr
    } else {
  	info default $instr [lindex $arglist 0] l
 	foreach {min max} $l break
 	return [list $instr [rand $min $max]]
    }
}
#-------------------------------------------------------------------------------
# создать случайную программу (список?) длиной не больше 'n'
#-------------------------------------------------------------------------------
proc randprog n {
    while {[incr n -1] >= 0} {
 	lappend prg [randinstr]
    }
    return $prg
}
#-------------------------------------------------------------------------------
# создать начальную популяцию программ с заданным числом особей и
# длинами (этих программ) из заданного диапазона
#-------------------------------------------------------------------------------
proc randpopulation {n minlen maxlen} {
    while {[incr n -1] >= 0} {
 	lappend result [randprog [rand $minlen $maxlen]]
    }
    return $result
}
#-------------------------------------------------------------------------------
# Двухточечный кроссовер. Используется для создания двух потомков
# от двух программ. Пример как это работает:
#
# Даны две программы: {A B C D E F} и {1 2 3 4 5 6 7 8 9}
# Определяем две случайные точки в обоих программах:
#
# {A B C D E F}
#    ^   ^
#
# {1 2 3 4 5 6 7 8 9}
#  ^         ^
#
# Два потомкка создаются используя внешнюю часть первой программы
# и внутреннюю часть второй и наоборот.
# Тогда первый потомок будет:
#
# {A 1 2 3 4 5 6 E F}
#
# и второй:
#
# {B C D 7 8 9}
#
# Входные программы -  'a' и 'b'; два скрещивания возвращаются как 
# двухэлементный список.
#-------------------------------------------------------------------------------
proc crossover {a b} {

    # получить четыре точки скрещивания
    set a0 [rand 0 [expr {[llength $a]-1}]]
    set a1 [rand 0 [expr {[llength $a]-1}]]
    set b0 [rand 0 [expr {[llength $b]-1}]]
    set b1 [rand 0 [expr {[llength $b]-1}]]

    # поменять две точки если необходимо, чтобы a0>=a1 и b0>=b1
    if {$a0 > $a1} {set t $a0; set a0 $a1; set a1 $t}
    if {$b0 > $b1} {set t $b0; set b0 $b1; set b1 $t}

    # получить левую/центральную/правую части каждой программы
    set aleft   [lrange $a 0 [expr {$a0-1}]]
    set acenter [lrange $a $a0 $a1]
    set aright  [lrange $a [expr {$a1+1}] end]

    set bleft   [lrange $b 0 [expr {$b0-1}]]
    set bcenter [lrange $b $b0 $b1]
    set bright  [lrange $b [expr {$b1+1}] end]

    # Теперь создаем кроссовер посредством соединения списков
    set x0 [concat $aleft $bcenter $aright]
    set x1 [concat $bleft $acenter $bright]

    list $x0 $x1
}
#-------------------------------------------------------------------------------
# По заданной программе возвращается мутированная программа, в которой каждая 
# инструкция будет заменена (или новая вставлена сразу за ней) с заданной 
# вероятностью '$p'.
#-------------------------------------------------------------------------------
proc mutate {program prob} {

    for {set i 0} {$i < [llength $program]} {incr i} {

 	if {[expr {rand()}] <= $prob} {            
 	    lset program $i [randinstr] ; # для Tcl-8.4            
 	}
 	if {[expr {rand()}] <= $prob} {
 	    set program [linsert $program $i [randinstr]]
 	}
    }

    return $program
}
#-------------------------------------------------------------------------------
# TclWisw (9) Extending Tcl in Tcl
#-------------------------------------------------------------------------------
proc repeat {n script} {
    while {[incr n -1] >= 0} {
        uplevel 1 $script    ;# вместо eval !!!!
        # but it does not work with break and continue ...
    }
}
#-------------------------------------------------------------------------------
# Ядро движка GP.
#-------------------------------------------------------------------------------
# 
# Создается случайная популяция заданного размера и стартует эволюционный
# процесс, вчисляющий рейтинг каждой программы, используя заданную
# "функцию годности." 
# На каждой итерации 1/3 популяции с лучшей годностью
# используется для создания другой 1/3 популяции через своих потомков
# и еще 1/3 - методом простой мутации исходных программ.
# После чего процесс эволюции повторяется.
# 
# Функция годности должна возвращать целое число, представляющее
# количество вычислительной ошибки сделанное программой.
# Она (функция) получает в качестве входного парпметра - особь популяции.
# Обычно фитнес-функция  вызывает процедуру "run" для запуска скрипта
# с значимым входящим стеком и ранжирует программу в соответствии с 
# ее выходом (результатом).
#
# На каждой итерации особь с лучшей годностью выводится на экран.
#
# Описание параметров:
#
# individuals: количество особей во всей популяции;
#              это число приближенно кратно 3.
# len:         максимальная длина особей в начальной популяции.
# fitnessfunc: фитнесс-функция (имя Tcl-процедуры).
# mutprob:     вероятность мутации, используемая процедурой 'mutate'.
#-------------------------------------------------------------------------------

proc evolve {individuals len fitnessfunc mutprob} {
    set population [randpopulation $individuals 1 $len]
    
    #for {set i 0} {$i < 40} {incr i} {   #while 1  }
    repeat 40 { ;############
        
 	# запустить каждую программу и записать в список саму прогу и ее фитнесс
 	set res {}
 	foreach prg $population {
 	    set fitness [$fitnessfunc $prg]
 	    lappend res [list $fitness $prg]
 	}
        
 	# сортировать особей по их фитнесу (низкая плохость == лучше)
 	set sorted [lsort -integer -index 0 $res]

 	# взять лидеров популяции (1/3) 
 	set l [expr {[llength $sorted]/3}]
 	set leaders [lrange $sorted 0 [expr {$l-1}]]
        
 	# генерировать другую 1/3 популяции потомками от случайных лидеров
 	set offsprings {}
 	while 1 {
 	    set x [rand 0 [expr {[llength $leaders]-1}]]
            
 	    set parent0 [lindex $leaders $x 1] ; # для Tcl-8.4
 	    set x [rand 0 [expr {[llength $leaders]-1}]]
 	    set parent1 [lindex $leaders $x 1] ; # для Tcl-8.4

 	    foreach {offspring0 offspring1} [crossover $parent0 $parent1] break
 	    lappend offsprings $offspring0
 	    if {[llength $offsprings] == $l} break
 	    lappend offsprings $offspring1
 	    if {[llength $offsprings] == $l} break
 	}

 	# генерировать последнюю 1/3 популяции мутацией лидеров
 	set mutated {}
 	foreach leader $leaders {
 	    lappend mutated [mutate [lindex $leader 1] $mutprob]
 	}

 	# склеить три популяции (лидеров, потомков, мутантов),
 	# создавая популяцию для следующей итерации
 	set new {}
 	foreach leader $leaders {
 	    lappend new [lindex $leader 1]
 	}
 	set population [concat $new $offsprings $mutated]

 	# печатать лучшую особь этой итерации:
 	puts "BEST: '[lindex $leaders 0 1]' with fitness [lindex $leaders 0 0]"
        
 	# печатать всю популяцию
 	#puts $population
 	if 0 {
 	    foreach p $population {
 		puts $p
 	    }
 	}
    }
}
#-------------------------------------------------------------------------------
################################################################################
